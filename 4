# 問4：経済全体の平均期待生涯効用

# importing libraries
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize_scalar

# utility function
def util(cons, gamma):
    return max(cons, 1e-4)**(1.0-gamma)/(1.0-gamma)

# parameters
gamma = 2.0
beta = 0.985**20
r = 1.025**20-1.0
JJ = 3
l = np.array([0.8027, 1.0, 1.2457])
NL = 3
prob = np.array([
    [0.7451, 0.2528, 0.0021],
    [0.1360, 0.7281, 0.1361],
    [0.0021, 0.2528, 0.7451]
])
mu_l1 = np.array([1.0/NL, 1.0/NL, 1.0/NL])
mu_l2 = np.zeros(NL)
for il in range(NL):
    for ilp in range(NL):
        mu_l2[ilp] += prob[il, ilp]*mu_l1[il]

# pension
tax_revenue = np.sum(l*mu_l2)*0.3
pension_fund = tax_revenue*(1+r)
y = pension_fund/1

# grids
a_l = 0.0
a_u = 2.0
NA = 100
a = np.linspace(a_l, a_u, NA)

# initialization
v = np.zeros((JJ, NA, NL))
iaplus = np.zeros((JJ, NA, NL), dtype=int)
aplus = np.zeros((JJ, NA, NL))
mu = np.zeros((JJ, NA, NL))
initial_ia = 0
for il in range(NL):
  mu[0, initial_ia, il] = mu_l1[il]

# 年金導入前

# period 3
for ia in range(NA):
    v[2, ia, :] = util((1.0+r)*a[ia], gamma)

# period 2
for il in range(NL):
    for ia in range(NA):
        reward = np.zeros(NA)
        for iap in range(NA):
            reward[iap] = util(l[il] + (1.0+r)*a[ia] - a[iap], gamma) + beta*v[2, iap, 0]
        iaplus[1, ia, il] = np.argmax(reward)
        aplus[1, ia, il] = a[iaplus[1, ia, il]]
        v[1, ia, il] = reward[iaplus[1, ia, il]]

# period 1
for il in range(NL):
    for ia in range(NA):
        reward = np.zeros(NA)
        for iap in range(NA):
            EV = 0.0
            for ilp in range(NL):
                EV += prob[il, ilp]*v[1, iap, ilp]
            reward[iap] = util(l[il] + (1.0+r)*a[ia] - a[iap], gamma) + beta*EV
        iaplus[0, ia, il] = np.argmax(reward)
        aplus[0, ia, il] = a[iaplus[0, ia, il]]
        v[0, ia, il] = reward[iaplus[0, ia, il]]

# average expected lifetime utility of the economy
total_utility = np.sum(v[0], axis=0)
aver_expected_lifetime_utility = np.sum(total_utility/NA * mu_l1)
print(aver_expected_lifetime_utility)

# 年金導入後

# period 3
for ia in range(NA):
    v[2, ia, :] = util(y + (1.0+r)*a[ia], gamma)

# period 2
for il in range(NL):
    for ia in range(NA):
        reward = np.zeros(NA)
        for iap in range(NA):
            reward[iap] = util(0.7*l[il] + (1.0+r)*a[ia] - a[iap], gamma) + beta*v[2, iap, 0]
        iaplus[1, ia, il] = np.argmax(reward)
        aplus[1, ia, il] = a[iaplus[1, ia, il]]
        v[1, ia, il] = reward[iaplus[1, ia, il]]

# period 1
for il in range(NL):
    for ia in range(NA):
        reward = np.zeros(NA)
        for iap in range(NA):
            EV = 0.0
            for ilp in range(NL):
                EV += prob[il, ilp]*v[1, iap, ilp]
            reward[iap] = util(l[il] + (1.0+r)*a[ia] - a[iap], gamma) + beta*EV
        iaplus[0, ia, il] = np.argmax(reward)
        aplus[0, ia, il] = a[iaplus[0, ia, il]]
        v[0, ia, il] = reward[iaplus[0, ia, il]]

# average expected lifetime utility of the economy
total_utility = np.sum(v[0], axis=0)
aver_expected_lifetime_utility = np.sum(total_utility/NA * mu_l1)
print(aver_expected_lifetime_utility)
